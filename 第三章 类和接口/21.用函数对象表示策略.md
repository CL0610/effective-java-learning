- 问题

  有些语言支持**函数指针、代理、lambda表达式**，或者支持类似的机制，允许程序把”调用特殊函数的能力”储存起来并传递这种能力。最常用的例子就是比较函数，通过传入不同的比较策略会得到不同的比较结果，这也正是策略模式的一个例子。可是Java没有提供函数指针。

- 解决方案

  **Java没有提供函数指针，但是可以用对象引用实现同样的功能**。调用对象上的方法通常是执行该对象上的某个操作。然而，我们也可能定义这样一种对象，它的方法执行其他对象上的操作。如果一个类**仅仅导出**这样的一个方法，它的实例上就等同于一个指向该方法的指针。这样的实例被称为函数对象。考虑这样一个类：

  1. ```
     class StringLengthComparator {
     	public int compare(String s1, String s2) {
     		return s1.length() - s2.length();
     	}
     }
     ```

  在这里，指向StringLengthComparator对象的引用可以被当作是一个指向该对象内部比较器compare的“函数指针”，可以在任意一对字符串上被调用，StringLengthComparator实例是用于比较字符串比较操作的具体策略。对于这种具体策略类，它的所有实例在功能上是相互等价的，所以根据前面的原则，将它作成是**Singleton**是非常合适的：

  ```
  class StringLengthComparator {
  	private StringLengthComparator() {}
  	public static final StringLengthComparator 
  		INSTANCE = new StringLengthComparator();
  	public int compare(String s1, String s2) {
  		return s1.length() - s2.length();
  	}
  }
  ```

  但是，用这述这种方法有个问题，就是**规定了参数的类型，这样就无法传递任何其他的比较策略**。相反，对于这种情况，应该定义一个Comparator接口，并修改StringLengthComparator来实现这个接口。换句话说，在设计具体的策略类时，还需要定义一个策略接口：

  ```
  // Strategy interface
  public interface Comparator<T> {
  	public int compare(T t1, T t2);
  }
  ```

  此时，前面的具体策略类声名如下：

  ```
  class StringLengthComparator implements Comparator<String> {
  	......
  } 
  ```

   这样，在传递具体策略类的对象的时候，只需要将参数类型定为接口类型(使用接口做类型定义)，现在可以传递其他的比较策略了, 具体策略类往往使用匿名类声明：

  ```
  Arrays.sort(stringArray, new Comparator<String>() {
  	public int compare(String s1, String s2) {
  		return s1.length() - s2.length();
  	}
  });
  ```

  这里存在一个问题，**就是在每次执行调用的时候都会创建一个新的实例**。如果它被重复执行，那就应该考虑将函数对象存储到一个**私有的静态final域里**并重用它。这样做的另一个好处就是为这个函数对象取一个有意义的声明。

  **因为策略接口被用做所有具体策略实例的类型，所以我们并不需要为了导出具体策略而把具体策略类做成公有的**。可以导出公有的静态域或者静态工厂方法，其类型是策略接口，具体的策略类可以是宿主类的私有嵌套类： 

  ```
  class Host {
  	private static class StrlenCmp implements Comparator<String>, Serializable {
  		public int compare(String s1, String s2) {
  			return s1.length() - s2.length();
  		}
  	}
  	// Returned comparator is serializable
  	public static final Comparator<String> STRING_LENGTH_COMPARATOR = new StrlenCmp();
  }
  ```

- 结论

  1. **函数指针的主要作用就是实现策略模式**，为了在Java中实现这种模式，要声名**一个接口来表示策略**，并且为每个具体策略声名一个实现了该接口的类；
  2. 当一个具体策略只被使用一次时，通常使用匿名类来声名和实例化这个具体策略；
  3. 当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为**私有的静态成员类，并通过公有的静态final域或静态工厂方法导出，其类型为策略接口**。