- 问题

  有时候通过一个标签域，让一个类实现多种风格的类的实例，这种类称之为**标签类**。

  ```
  public class Figure {
      enum Shape { RECTANGLE,CIRCLE };
      //Tag field - the shape of this figure
      final Shape shape;
      //These fields are used only if shape is RECTANGLE
      double length;
      double width;
      //This field is used only if shape is CIRCLE
      double radius;
      //Constructor for circle
      Figure(double redius){
          shape=Shape.CIRCLE;
          this.radius=radius;
      }
      //Constructor for rectangle
      public Figure (double lenght,double width) {
         shape=Shape.RECTANGLE;
          this.length=lenght;
          this.width=width;
      }
      double area(){
          switch (shape){
              case RECTANGLE:return length*width;
              case CIRCLE:return Math.PI*(radius * radius);
              default:throw new AssertionError();
          }
      }
  }
  ```

  如上例就是一个典型的标签类，一个类通过标签域shape来实现了圆形和矩形这两个不同类型的实例。 这种标签类（tagged class）有着许多的缺点。它们中充斥着样板代码，包括枚举声明、标签域以及条件语句。

  1. 多个实现乱七八糟地挤在了单个类中，**破坏了可读性**；
  2. **增加了内存的占用**，因为实例承担着属于其他风格的不相关域；
  3. **域不能做成final的**，除非构造器初始化相关的域，如果不需要初始化相关域，那就会需要增加更多的样板代码；
  4. 无法给标签类添加风格，除非可以修改它的源文件，如果一定要添加风格，就必须记得给每个条件语句都添加一个条件，否则类就会在运行时失败；
  5. 数据类型没有提供任何关于其风格的线索；

  **标签类过于冗长、容易出错，并且效率低下**。

- 解决

  Java提供了其他更好的方法来定义能表示多种风格对象的单个数据类型：**子类型化**。标签类正是类层次的一种简单效仿。 为了将标签类转化成类层次，有这样一些步骤：

  1. 首先要为标签类中的每一个方法都定义一个包含抽象方法的抽象类，这每个方法的行为都依赖于标签值。在Figure类中，只有一个这样的方法：area。 这个抽象类是类层次的根；

  2. 如果还有其他的方法行为不依赖于某个标签的值，就把这样的方法放到这个类中；

  3. 同样的，如果所有的方法都用到了某些数据域，就应该把他们放在这个类中。

     将上面的标签类Figure转换成类层次结构：

  ```
  abstract class Figure {
  	abstract double area();
  }
  class Circle extends Figure {
  	final double radius;
  	public Circle(double radius) {
  		this.radius = radius;
  	}
  	double area() {
  		return Math.PI * (radius * radius);
  	}
  }
  class Rectangle extends Figure {
  	final double length;
  	final double width;
  	public Rectangle(double length, double width) {
  		this.length = length;
  		this.width = width;
  	}
  	double area() {
  		return length * width;
  	}
  }
  ```

  这个类层次纠正了前面提到过的标签类的所有缺点：

  1. 这段代码简洁而清楚，**没有包含在原来的版本中所见到的所有样本代码；**
  2. 每个类型的实现都配有自己的类，这些类都**没有受到不相关域的拖累**。**所有的域都是final的**。**编译器确保每个类的构造器都初始化它的数据域**；
  3. **对于顶层类中声名的每个抽象方法，都确保有一个实现**。这样就杜绝了因为遗漏switch case而导致运行时失败的可能；
  4. **多个程序员可以独立的扩展层次结构**。并且不用访问根类的源代码就能相互操作；
  5. **每种类型都有一种相关的独立的数据类型**，就是相应的子类类型，允许程序员指明变量的类型，限制变量，并将参数输入到特殊的类型；
  6. 类层次的另一个好处在于，**它们可以用来反映类型之间本质上的层次关系**。有助于增强灵活性，并进行更好的编译时类型检查。

- 结论

  标签类很少有适用的时候。当想要编写一个包含显示标签域的类时，应该考虑一下，这个标签是否可以被取消，是否可以用**类层次**来代替。**当遇到一个包含标签域的现有类时，就要考虑一下将它重构到一个层次结构中去**。