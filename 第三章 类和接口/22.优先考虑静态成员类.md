- 问题

  嵌套类（nested class）是指被定义在另一个类的内部的类。嵌套类存在的目的应该是为它的外围类（enclosing class）提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该是顶层类（top-level class）。嵌套类有四种：**静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和局部类（local class）**。除了第一种之外，其他三种都被称为内部类（inner class）。那么，在什么情况下使用应该使用哪种嵌套类才是合适的？

- 解决方案

  1. 静态成员类

     静态成员类是最简单的一种嵌套类。**最好把它看作是普通的类，只是碰巧被声明在另一个类的内部而已**，它可以访问外围类的所有成员，包括那些声明为私有的成员。静态成员类是外围类的一个静态成员，与其他的静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，它就只能在外围类的内部才可以被访问。

     静态成员类的一种常见的用法就是作为公有的**辅助类**，仅当它的外部类一起使用时才有意义。例如，一个描述了计算器支持的各种操作的枚举。Operation枚举应该是Calculator类的公有静态成员类，然后使用Calculator类的客户端就可以用诸如Calculator.Operation.PLUS这样的名称来引用这些操作。

     **私有静态成员类的一种常见用法用来代表外围类所代表的对象的组件。**例如，考虑一个Map实例，他把键和值关联起来。许多Map实现的内部都有一个Entry对象，对应于map中的每个键值对。虽然每个entry都与一个map关联，但是entry上的方法并不需要访问该map。因此，使用非静态成员来表示entry是很浪费的：private修饰的静态成员类是最佳的选择。如果不小心漏掉了entry声明中的static修饰符，该map依然可以工作，但是每个entry中将会包含一个指向该map的引用，这样就浪费了空间和时间。

  2. 非静态成员类

     从语法上讲，**静态成员类和非静态成员类之间唯一的区别是，静态成员类的声明中包含了修饰符static**。尽管他们的语法非常的相似，但是这两种嵌套类有很大的不同。非静态成员类的每个实例都隐含着与外围类的一个外围实例（enclosing instance）相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this获得外围实例的引用。**如果嵌套类的实例可以在外围类的实例之外独立存在，这个嵌套类就必须是静态成员类，**在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。

     当非静态成员类的实例被创建的时候，它和外围实例之间的关联关系也随之建立起来；而且，这种关联关系以后也不能被修改。通常情况下，当在外围类的某个实例方法的内部调用了非静态成员类的构造器时，这种管理就自动建立起来。使用表达式enclosingInstance.new MemberClass(args)来手工建立这种关系也是有可能的，但是很少使用。

     **非静态成员类常见用法是定义一个Adapter**，它允许外部类的实例被看作是另一个不相关的类的实例。例如，Map接口的实现往往使用非静态成员类来实现它们的集合视图（collection view），这些集合视图是由Map的keySet、entrySet和Values方法返回的。同样地，诸如Set和List这种集合接口的实现往往也是用非静态成员类来实现他们的迭代器（iterator）：

     ```
     public class MySet<E> extends AbstractSet<E>
     {
     	public Iterator<E> iterator(){
     		return new MyIterator();
     	}
     	private class MyIterator implements Iterator<E>{
     	}
     }
     
     ```

     **静态成员类 VS 非静态成员类**

     1. **如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的生命中，使它成为静态成员类，而不是非静态成员类。**如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保存这份引用要消耗时间和空间，并且会**导致外围实例在符合垃圾回收时仍然得以保留，造成内存泄漏**；
     2. **如果没有外围实例的情况下，也需要分配内部类实例，就不能使用非静态成员类**，因为非静态成员类的实例必须要有一个外围实例。

  3. 匿名类

     **匿名类没有类名，它不是外围类的一个成员，并不与其他的成员一起被声明，而是在使用的同时被声明和实例化。**匿名类可以出现在代码中任何允许存在表达式的地方。当且仅当匿名类出现在非静态的环境中时，它才有外围实例。但是即使它们出现在静态的环境中，也不可能拥有任何静态成员。

     匿名类的适用性受到诸多的限制。**除了在它们被声明的时候之外，是无法将它们实例化的，你不能执行instanceof测试。**你无法声明一个匿名类来实现多个接口，或者扩展一个类，并同时扩展类和实现接口。由于匿名类出现在表达式当中，它们必须保持简短——大约10行或者更少些——否则会影响程序的可读性。

     匿名类多用于表示具体策略的函数对象，比如Arrays.sort()方法中定义的比较器Comparator，还可用于创建Thread时的Runnable等。

  4. 局部类

     局部类是四种嵌套类中用的最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。局部类与其他三种嵌套类中的每一种都有一些共同的属性。**与成员类一样，局部类有名字，可以被重复使用。与匿名类一样，只有当局部类实在非静态环境中定义的时候，才有外围实例，它们也不能包含静态成员。与匿名类一样，它们必须简短以便不会影响到可读性**。

- 总结

  简而言之，共有四种不同的嵌套类，每一种都有自己的用途。

  1. 如果一个嵌套类需要在单个方法之外仍然可见的，或者它太长了，不适合于放在方法内部，就应该使用成员类；
  2. **如果成员类的每个示例都需要一个指向外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的；**
  3. 假设调用一个方法（如Array.sort()），该方法的入参需要创建一个实例，并且已经有一个确定的类型，创建该类的实例时就可以采用创建匿名类的方式来创建该类的实例。如果没有一个现有的类型，就设计成局部类。