- 问题

  我们通常将包含静态方法和静态域的类作为工具类。比如说可以用这种类来组织某种基本类型的相关方法（java.lang.Math），也可以通过java.util.Collections方式把实现特定接口的对象上的静态方法组织起来，最后还能利用这种类把final类上的方法组织起来，以取代扩展该类的做法。

  这种工具类的实例化是没有任何用处的，但是需要注意到的是在不提供构造函数的时候，**编译器会自动提供一个默认的构造器**，这会造成无意识的实例化。一种补救方法是企图将类做成抽象类来阻止实例化，但是这种方法并不可靠，因为抽象类可以被继承，而它的子类是可以实例化的，这样甚至会误导用户以为这个类就是做出来让用户来继承使用的。针对这种工具类应该如何避免被实例化？

- 解决

  避免被实例化最简单而且可靠的方法是，通过显示的提供一个私有的构造函数来阻止实例化。比如：

  ```
  // Noninstantiable utility class
  public class UtilityClass {
  	// Suppress default constructor for noninstantiability
  	private UtilityClass() {
  		//防止在类的内部被调用实例化
  		//或者被反射攻击
  		throw new AssertionError();
  	}
  }
  ```

  **可以通过将构造器方法访问标识符设置为private，将构造器方法私有化，从而将对象强化为不可实例化**。比如在只包含静态域和静态方法的工具类，就有必要通过私有化构造器的方式，让工具类不可被实例化。

- 结论

  当诸如工具类这种类，被实例化是没有多大意义的，**应该强制将构造器私有化，以强化类的不可实例化属性。