# Summary

* [Introduction](README.md)
* 1.创建和销毁对象
    * [2.多个参数使用Builder模式创建对象](第一章 创建和销毁对象/2.多个参数使用Builder模式创建对象.md)
    * [3.使用枚举类型强化singleton](第一章 创建和销毁对象/3.使用枚举类型强化singleton.md)
    * [4.私有构造器以强化对象不可实例化](第一章 创建和销毁对象/4.私有构造器以强化对象不可实例化.md)
    * [5.避免创建不必要的对象](第一章 创建和销毁对象/5.避免创建不必要的对象.md)
    * [6.消除过期的对象引用](第一章 创建和销毁对象/6.消除过期的对象引用.md)
    * [7.避免使用finalize()方法](第一章 创建和销毁对象/7.避免使用finalize方法.md)
* 2.对象通用的方法
	* [8.覆盖equals方法请遵守通用规定](第二章 对象通用的方法/8.覆盖equals方法请遵守通用规定.md)
	* [9.覆盖equals时要同时覆盖hashCode](第二章 对象通用的方法/9.覆盖equals时要同时覆盖hashCode.md)
	* [10.覆盖toString](第二章 对象通用的方法/10.覆盖toString.md)
	* [12.考虑实现Comparable接口](第二章 对象通用的方法/12.考虑实现Comparable接口.md)
* 3.类和接口
	* [13.使类和成员的可访问性最小化](第三章 类和接口/13.使类和成员的可访问性最小化.md)
	* [14.在公有类中使用访问方法而非公有域](第三章 类和接口/14.在公有类中使用访问方法而非公有域.md)
	* [15.使可变性最小化](第三章 类和接口/15.使可变性最小化.md)
	* [16.复合优于继承](第三章 类和接口/16.复合优于继承.md)
	* [17.要么为继承而设计，并提供文档说明，要么就禁止继承](第三章 类和接口/17.要么为继承而设计，并提供文档说明，要么就禁止继承.md)
	* [19.接口只用于定义类型](第三章 类和接口/19.接口只用于定义类型.md)
	* [20.类层次优于标签类](第三章 类和接口/20.类层次优于标签类.md)
	* [21.用函数对象表示策略](第三章 类和接口/21.用函数对象表示策略.md)
	* [22.优先考虑静态成员类](第三章 类和接口/22.优先考虑静态成员类.md)
* 4.泛型
    * [23.使用泛型不要使用原生类型](第四章 泛型/23.使用泛型时不要使用原生态类型（raw type）.md)
    * [24.消除非受检警告](第四章 泛型/24.消除非受检警告.md)
    * [25.List优于数组](第四章 泛型/25.List优于数组.md)
* 5.枚举和注解
	* [30.使用枚举代替int常量](第五章 枚举和注解/30.使用枚举代替int 常量.md)
	* [31.用实例域代替序数](第五章 枚举和注解/31.用实例域代替序数.md)
	* [32.用EnumSet代替位域](第五章 枚举和注解/32.用EnumSet代替位域.md)
	* [33.用EnumMap代替序数索引](第五章 枚举和注解/33.用EnumMap代替序数索引.md)
	* [35.注解优于命名模式](第五章 枚举和注解/35.注解优于命名模式.md)
* 6.方法
    * [38.检查方法参数的有效性](第六章 方法/38.检查方法参数的有效性.md)
	* [39.参数进行保护性拷贝](第六章 方法/39.参数进行保护性拷贝.md) 
    * [40.谨慎的设计方法签名](第六章 方法/40.谨慎的设计方法签名.md) 
	* [41.慎用重载](第六章 方法/41.慎用重载.md) 
	* [42.慎用可变参数](第六章 方法/42.慎用可变参数.md) 
	* [43.返回长度为0的集合或者数组，而不是null](第六章 方法/43.返回长度为0的集合或者数组，而不是null.md) 
	* [44.API需要编写文档注释](第六章 方法/44.API需要编写文档注释.md) 
* 7.通用程序设计
    * [45.将局部变量的作用域最小化](第七章 通用程序设计/45.将局部变量的作用域最小化.md)
	* [46.for-each循环优于传统的for循环](第七章 通用程序设计/46.for-each循环优于传统的for循环.md)
	* [47.多使用类库](第七章 通用程序设计/47.多使用类库.md)
	* [48.需要精确答案，请避免使用float和double](第七章 通用程序设计/48.需要精确答案，请避免使用float和double.md)
	* [49.基本类型优先于装箱基本类型](第七章 通用程序设计/49.基本类型优先于装箱基本类型.md)
	* [50.尽量避免使用字符串](第七章 通用程序设计/50.尽量避免使用字符串.md)
	* [51.谨慎使用字符串连接符](第七章 通用程序设计/51.谨慎使用字符串连接符.md)
	* [52.通过接口引用对象](第七章 通用程序设计/52.通过接口引用对象.md)
	* [53.慎用反射机制](第七章 通用程序设计/53.慎用反射机制.md)
	* [54.慎用本地方法](第七章 通用程序设计/54.慎用本地方法.md)
	* [55.谨慎的进行优化](第七章 通用程序设计/55.谨慎的进行优化.md)
	* [56.遵守普遍接受的命名规则](第七章 通用程序设计/56.遵守普遍接受的命名规则.md)
* 8.异常
	* [57.只针对异常的情况才使用异常](第八章 异常/57.只针对异常的情况才使用异常.md)
	* [58.选择合适的异常](第八章 异常/58.选择合适的异常.md)
	* [59.避免不必要的使用受检的异常](第八章 异常/59.避免不必要的使用受检的异常.md)
	* [61.抛出与抽象相对应的异常](第八章 异常/61.抛出与抽象相对应的异常.md)
	* [62.每个方法抛出的异常都要有文档](第八章 异常/62.每个方法抛出的异常都要有文档.md)
	* [63.编写合适的异常信息](第八章 异常/63.编写合适的异常信息.md)
	* [65.不要忽略异常](第八章 异常/65.不要忽略异常.md)
* 9.并发
	* [66.同步访问共享的可变数据](第九章 并发/66.同步访问共享的可变数据.md)
	* [68.executor和task优于创建线程](第九章 并发/68.executor和task优于创建线程.md)
	* [69.优先使用提供的并发工具](第九章 并发/69.优先使用提供的并发工具.md)
	* [70.线程安全性的文档化](第九章 并发/70.线程安全性的文档化.md)
	* [71.慎用延迟初始化](第九章 并发/71.慎用延迟初始化.md)
	* [72.不要依赖于线程调度器](第九章 并发/72.不要依赖于线程调度器.md)
	* [73.避免使用线程组](第九章 并发/73.避免使用线程组.md)
* 9.序列化
	* [74.谨慎的实现Serializable接口](第十章 序列化/74.谨慎的实现Serializable接口.md)
	* [75.考虑使用自定义的序列化形式](第十章 序列化/75.考虑使用自定义的序列化形式.md)
	* [76.保护性地编写readObject方法](第十章 序列化/76.保护性地编写readObject方法.md)
	* [77.单例模式，枚举类型优先于readResolve](第十章 序列化/77.单例模式，枚举类型优先于readResolve.md)
	* [78.考虑用序列化代理代替序列化实例](第十章 序列化/78.考虑用序列化代理代替序列化实例.md)










