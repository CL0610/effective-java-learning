- 问题

  在每个覆盖了equals方法的类中，也必须覆盖hashCode方法，如果不这样的话，就会违反了Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常动作，比如说HashMap，HashSet，Hashtable。那么，Object.hashCode规范是什么？以及一个性能良好的hashCode应该怎样写？

- 解决

  1. Object.hashCode规范

     - **在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须都始终如一地返回同一个整数**
     - **如果两个对象根据equals(Object)方法比较是相等的。那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。**
     - **如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中的任意一个对象的hashCode方法，则不一定要产生不同的整数结果。**

  2. hashCode的写法

     一个好的散列函数通常**倾向于“为不相等的对象产生不相等的hashCode”**，编写好的hashCode也如下这种简单的方式：

     1. 把某个非零的常数值，比如说17保存在一个名为result的int类型的变量中。
     2. 对于对象中的每个关键域f(指equals方法中涉及的每个域)，完成以下步骤：

  ​             a. 为该域计算int类型的散列码c:

  ​                   1)  如果该域是boolean类型，则计算(f ? 1 : 0)

  ​                   2).  如果该域是byte、char、short或者int类型，则计算(int)f

  ​                   3) 如果该域是long类型，则计算(int)(f^(f>>>32))。

  ​                   4) 如果该域是float类型，则计算Float.floatToIntBits(f)。

  ​                   5) 如果该域是double类型，则计算Double.doubleToLongBits(f)，然后按照步								骤2.a.3)，为得到的long类型值计算散列值。

  ​                   6) 如果该域是一个对象引用，并且该类的equals方法通过递归地调用equals方式来比较这个域，则同样为这个域递归地调用hashCode。如果需要更复杂的比较，则为这个域计算一个范式，然后针对这个范式调用hashCode。如果这个域的值为null，则返回0（不绝对，但通常是0）。

  ​                   7) 如果该域是一个数组，则要把每个元素当做单独的域来处理。也就是说，递归地应用上面的规则，对每个重要的元素计算一个散列码。然后再用2中的方法组合起来。如果数组中的每个元素都很重要，则可以用Arrays.hashCode方法。

  ​              b. 按照下面的公式，把步骤2.a计算得到的散列码c合并到result中。

  ​              result = 31 * result + c;

  ​	3. 返回result。

  1. 示例

     ```
     public final class PhoneNumber {
     	private final short areaCode;
     	private final short prefix;
     	private final short lineNumber;
     	
     	@Override
         public int hashCode() {
             int result = 17;
             result = 31 * result + areaCode;
             result = 31 * result + prefix;
             result = 31 * result + lineNumber;
             return result;
         }
     }
     ```

- 结论

  1. 如果覆盖了equals方法一定要覆盖hashCode方法，否则会造成基于散列值得集合使用出现问题，如HashMap或者HashSet等；
  2. **不要试图从散列码计算中排除一个对象的关键部分来提高性能。**虽然这样可能使计算的速度得到提升，但是效果并不见得会好，可以会导致散列表慢到根本无法使用，如果因此大量的实例映射到极少的散列码上，那基于散列的集合将会显示出平方级的性能。Java平台类库中的许多类如 String、Integer、Date，都可以把它们的hashCode方法返回确切值规定为该实例的一个函数，一般来说，这并不是一个好主意，因为这样做严格地限制了在将来的版本中改进散列函数的能力。